{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This website is under construction.</p> <p>Named Data Networking (NDN)1 is a future Internet architecture inspired by years of research into network usage and a growing awareness of unsolved problems in the contemporary protocols. Many of these problems arise due to the fundamental mismatch between the data-centric usage of the Internet and the host-centric nature of IP. NDN is designed as a data-centric replacement of the TCP/IP architecture, thus overcoming this mismatch by replacing the network layer itself. The NDN project is now a collaborative effort of a large community of researchers at more than a dozen institutions.</p> <p>NDN retains the Internet's hourglass architecture but evolves the thin waist to allow the creation of completely general distribution networks. The core element of this evolution is removing the restriction that packets can only identify communication endpoints. As far as the network is concerned, the identifier in an NDN packet can be anything \u2014 an endpoint, a chunk of movie or book, a command to turn on some lights, etc. This conceptually simple change allows NDN networks to use almost all of the Internet\u2019s well understood and well tested engineering properties to efficiently solve not only communication problems but also digital distribution and control problems.</p> <p>A more detailed discussion can be found at the website of the NDN project (named-data.net)</p> <p>The design of NDN naturally leads to several advantages over IP and IP-based protocols. Some of these are briefly described below.</p> <ul> <li> <p>Data-Centric Security: NDN provides data-centric security2 where it secures data directly rather than relying on securing the channels that transmit the data. Each packet of data carries a cryptographic signature that binds the name, contents and the identity of the producer of the data.</p> </li> <li> <p>Privacy: NDN provides privacy by allowing consumers to retrieve data without needing to expose their identity to the network. This is in contrast to IP where the source and destination addresses are exposed in every packet.</p> </li> <li> <p>Name-based Forwarding: NDN packets are routed and forwarded using their names. This allows NDN routers to make forwarding decisions based on application semantics rather than just network addresses. This also directly provides support for anycast for applications.</p> </li> <li> <p>Intelligent Data Plane: NDN utilizes a stateful forwarding plane where forwarders track the requests and responses of data. This allows NDN to support a wide range of advanced features such as adaptive and multipath forwarding, and provides DDoS protection3 and congestion control4 at the network layer.</p> </li> <li> <p>Multicast and Caching: The stateful forwarding plane allows for aggregation of requests and responses, which enables efficient multicast of all Data packets. Since NDN packets are individually secured and do not rely on channel security, data is also securely cached at every forwarder in the network, creating a massive distributed cache.</p> </li> </ul> <p>The NDN project also maintains a large open source code base, with NDN forwarders, debugging tools and libraries available in multiple languages including C++, python, go, TypeScript etc. Most of this code is available at the GitHub.</p> <ol> <li> <p>Zhang, L. et al. 2014. Named Data Networking. ACM SIGCOMM Computer Communication Review (CCR). 44, 3 (2014), 66\u201373. DOI:https://doi.org/10.1145/2656877.2656887.\u00a0\u21a9</p> </li> <li> <p>Zhang, Z. et al. 2018. An overview of security support in named data networking. IEEE Communications Magazine. 56, 11 (2018), 62\u201368. DOI:https://doi.org/10.1109/MCOM.2018.1701147.\u00a0\u21a9</p> </li> <li> <p>Gasti, P. et al. 2013. DoS and DDoS in named data networking. 2013 22nd international conference on computer communication and networks (ICCCN) (2013), 1\u20137.\u00a0\u21a9</p> </li> <li> <p>Song, S. and Zhang, L. 2022. Effective NDN congestion control based on queue size feedback. Proceedings of the 9th ACM conference on information-centric networking (New York, NY, USA, 2022), 11\u201321.\u00a0\u21a9</p> </li> </ol>"},{"location":"communication/","title":"Communication","text":"<p>NDN applications fetch data using Interest-Data packet exchanges. The process of such an exchange can be summarized as follows:</p> <ol> <li>An application that desires a piece of data sends an Interest packet.      The Interest packet contains the name of the data being requested.</li> <li>The network forwards the Interest packet to the node(s) having a copy of the data.</li> <li>On receiving the Interest packet, a node may reply with a matching Data packet.</li> <li>The network the forwards this Data packet back to the requesting application.</li> </ol> <p>Types of Applications</p> <p>Applications that send Interests to fetch data packets are called \"consumers\". Likewise, applications that serve Data in response to Interests are called \"producers\". An application may act as both a consumer and a producer simultaneously.</p>"},{"location":"communication/#consumer","title":"Consumer","text":"<p>Consumers are applications that send Interest packets to fetch data. The Interest packet contains the name of the data being requested along with any optional selectors. The following snippet illustrates how to send an Interest packet and get back the corresponding Data.</p> <p>For this example to work, you must first run the producer from the next part.</p> ndn-cxxpython-ndnNDNts <pre><code>#include &lt;iostream&gt;\n#include &lt;ndn-cxx/face.hpp&gt;\n\nint main(int argc, char** argv)\n{\n// Create an Interest packet\nndn::Interest interest(\"/edu/ucla/cs/118/notes\");\n\n// Connect to the local forwarder over a Unix socket\nndn::Face face;\n\n// Send the Interest packet and get back the Data packet\nface.expressInterest(interest,\n[](const ndn::Interest&amp;, const ndn::Data&amp; data) {\n// Received a Data packet reply\nstd::cout &lt;&lt; data &lt;&lt; std::endl;\n},\n[](const ndn::Interest&amp;, const ndn::lp::Nack&amp; nack) {\n// Received a Nack (negative acknowledgement)\nstd::cout &lt;&lt; \"Nack received: \" &lt;&lt; nack.getReason() &lt;&lt; std::endl;\n},\n[](const ndn::Interest&amp;) {\n// The Interest has timed out\nstd::cout &lt;&lt; \"Timeout\" &lt;&lt; std::endl;\n});\n\n// Start face processing loop\nface.processEvents();\n}\n</code></pre> <pre><code>from ndn.app import NDNApp\nfrom ndn.encoding import Name\n\n# Connect to the local forwarder over a Unix socket\napp = NDNApp()\n\nasync def main():\n    try:\n        data_name, meta_info, content = await app.express_interest(\"/edu/ucla/cs/118/notes\")\n\n        # Received a Data packet\n        print(f'Received Data Name: {Name.to_str(data_name)}')\n        print(meta_info)\n        print(bytes(content) if content else None)\n\n    except InterestNack as e:\n        # Received a Nack (negative acknowledgement)\n        print(f'Nacked with reason={e.reason}')\n    except InterestTimeout:\n        # The Interest has timed out\n        print(f'Timeout')\n    except InterestCanceled:\n        # Connection to the local NDN forwarder is broken\n        print(f'Canceled')\n    except ValidationFailure:\n        # Security validation failed for the data\n        print(f'Data failed to validate')\n\n    finally:\n        # Disconnect from the local forwarder\n        app.shutdown()\n\nif __name__ == '__main__':\n    app.run_forever(after_start=main())\n</code></pre> <pre><code>import { Interest } from '@ndn/packet';\nimport { WsTransport } from '@ndn/ws-transport';\nimport { Endpoint } from '@ndn/endpoint';\n\n// Code running in the browser cannot connect to a local Unix socket.\n// In this example, we connect to a remote NFD instance, running as\n// a part of the global NDN testbed.\nconst uplink = await WsTransport.createFace({}, \"wss://suns.cs.ucla.edu/ws/\");\nconsole.log(`Connected to NFD at ${uplink.remoteAddress}`);\n\n// Construct an Endpoint on the default forwarder instance.\nconst endpoint = new Endpoint();\n\n// Create an Interest packet\nconst interest = new Interest(`/ndn/edu/arizona/ping/NDNts/${Date.now()}`);\n\n// Send the Interest packet and wait for the Data packet\ntry {\nconst data = await endpoint.consume(interest);\nconsole.log(`Received data with name [${data.name}]`);\n} catch (err: any) {\nconsole.warn(err);\n}\n\n// Disconnect from the remote NFD instance\nuplink.close();\n</code></pre>"},{"location":"communication/#producer","title":"Producer","text":"<p>To serve data to other applications, a producer must register a name prefix with the network.</p> <ol> <li>The producer sends a registration request to the network carrying a name prefix.</li> <li>A route to the prefix is registered at the local forwarder, and may be propagated to other forwarders in the network.</li> <li>The producer is notified of the successful registration.</li> <li>Any Interest packets matching the prefix may now be forwarded to the producer.</li> </ol> <p>The following snippet illustrates how to serve data by registering a name prefix route at the local forwarder. Make sure to start NFD on your development machine before running this example.</p> ndn-cxxpython-ndn <pre><code>#include &lt;iostream&gt;\n#include &lt;ndn-cxx/face.hpp&gt;\n#include &lt;ndn-cxx/security/key-chain.hpp&gt;\n\nint main(int argc, char** argv)\n{\n// Connect to the local forwarder over a Unix socket\nndn::Face face;\n\n// Connect to the local KeyChain to sign Data packets\n// Note: Security is not optional in NDN\nndn::KeyChain keychain;\n\n// Register a prefix with the local forwarder\nface.setInterestFilter(\"/edu/ucla/cs/118/notes\",\n[&amp;face, &amp;keychain](const ndn::InterestFilter&amp;, const ndn::Interest&amp; interest) {\nstd::cout &lt;&lt; \"Received Interest packet for \" &lt;&lt; interest.getName() &lt;&lt; std::endl;\n\n// Create a Data packet with the same name as the Interest\nndn::Data data(interest.getName());\n\n// Set the Data packet's content to \"Hello, World!\"\ndata.setContent(ndn::make_span(reinterpret_cast&lt;const uint8_t*&gt;(\"Hello, NDN!\"), 11));\n\n// Sign the Data packet with default identity\nkeychain.sign(data);\n\n// Return the Data packet to the network\nface.put(data);\n},\n\n// Register prefix failure handler -- optional\nnullptr,\n\n// Register prefix failure handler\n[](const ndn::Name&amp; prefix, const std::string&amp; reason) {\nstd::cout &lt;&lt; \"Route registration failed\" &lt;&lt; std::endl;\n});\n\n// Start face processing loop\nface.processEvents();\n}\n</code></pre> <pre><code>from typing import Optional\nfrom ndn.app import NDNApp\nfrom ndn.encoding import Name, InterestParam, BinaryStr, FormalName\n\n# Connect to the local forwarder over a Unix socket\napp = NDNApp()\n\n# Register a prefix, and call on_interest when a matching Interest is received\n@app.route('/edu/ucla/cs/118/notes')\ndef on_interest(name: FormalName, param: InterestParam, _app_param: Optional[BinaryStr]):\n    print(f'Received Interest packet for {Name.to_str(name)}')\n\n    # Create the content bytes for the Data packet\n    content = \"Hello, NDN!\".encode()\n\n    # Sign and send the Data packet back to the network\n    app.put_data(name, content=content, freshness_period=10000)\n\nif __name__ == '__main__':\n    app.run_forever()\n</code></pre>"},{"location":"communication/#faces","title":"Faces","text":"<p>Under Construction</p>"},{"location":"debugging/","title":"Debugging","text":"<p>This page is under construction.</p>"},{"location":"forwarding/","title":"Forwarding Plane","text":"<p>NDN uses a stateful forwarding plane1 that maintains several tables at forwarders. This is in contrast to the stateless forwarding plane of IP, which does not maintain any per-packet state. The stateful forwarding plane of NDN enables Data multicast and caching, along with other features such as privacy, loop detection, network-layer congestion control2 and DoS protection3.</p> <p>Each instance of NFD in an NDN network maintains several tables. Some of these tables store per-packet state, thus making the forwarding plane stateful. The most important of these tables are described briefly in the following sections.</p> <p>Further Reading</p> <p>If you are interested in the implementation details of NFD, please refer to the NFD Developer Guide.</p>"},{"location":"forwarding/#forwarding-information-base","title":"Forwarding Information Base","text":"<p>The FIB is a forwarding table similar to the one found in IP routers, which maps name prefixes to outgoing faces. It is used by NFD to forward Interest packets. Each entry in the FIB contains the following information.</p> <ul> <li>A name prefix.</li> <li>A set of next hops (outgoing faces).</li> <li>The cost of each next hop face.</li> </ul> <p>When NFD receives an Interest which must be forwarded, it looks up the FIB for the longest matching prefix. If a matching entry is found, the Interest may be forwarded to one or more faces specified in the entry. The exact decision of which face(s) to forward the Interest on is made by the strategy matching the prefix, as described in the next section.</p>"},{"location":"forwarding/#strategy-table","title":"Strategy Table","text":"<p>The strategy table is used by NFD to decide which strategy to use for forwarding a given Interest. Each entry in the strategy table contains the following information.</p> <ul> <li>A name prefix.</li> <li>The name of the strategy to use for forwarding Interests matching the prefix.</li> </ul> <p>When NFD receives an Interest which must be forwarded, it looks up the strategy table for the longest matching prefix. The matching strategy is then used to decide which face(s) to forward the Interest on.</p> <p>Some examples of strategies are,</p> <ul> <li>Best route: Use the next hop with the lowest cost.</li> <li>Multicast: Forward the Interest to all next hops.</li> <li>ASF: Use the Adaptive Smoothed RTT-based Forwarding (ASF) algorithm4.</li> </ul>"},{"location":"forwarding/#pending-interest-table","title":"Pending Interest Table","text":"<p>The PIT is the most important table in the forwarding plane, and it provides the basic support for the pull model of communication in NDN.</p> <p>When NFD receives an Interest, it stores a PIT entry in this table. Each PIT entry contains the following information.</p> <ul> <li>The name of the Interest along with any selectors.</li> <li>The incoming face on which the Interest was received (in-record).</li> <li>The outgoing face(s) on which the Interest was forwarded (out-record).</li> <li>The time at which the Interest will expire (lifetime).</li> </ul> <p>On receiving a Data packet, NFD performs the following steps.</p> <ul> <li>Looks up the PIT for an entry matching the Data packet.</li> <li>If such an entry is found, the Data packet is forwarded on the incoming face     of the PIT entry, and the PIT entry is removed from the table.</li> <li>If no matching PIT entry is found, the Data packet is dropped.</li> </ul> <p>The PIT entry is also dropped if the Interest times out before a matching Data packet is received.</p> <p>One-Interest One-Data</p> <p>A fundamental principle of NDN is that one outgoing Interest can bring back at most one Data packet. This is enforced by the PIT, since the PIT entry is removed from the table as soon as a matching Data packet is received and forwarded to the incoming face.</p> <p>Breadcrumb Trail</p> <p>In an NDN network containing multiple forwarders, PIT entries for an Interest serve as a breadcrumb trail that the Data packet follows back to the consumer. As a result, no source address is required in the Interest packet for sending the Data packet back to the consumer.</p> <p>Implementation of PIT</p> <p>For efficiency, forwarders may implement the PIT using tree-based data structures or hash tables. The entry expiration is typically implemented using priority queues.</p>"},{"location":"forwarding/#data-multicast","title":"Data Multicast","text":"<p>The per-packet statefulness of the PIT directly enables Data multicast by allowing a single Data packet to be forwarded to multiple consumers that have expressed an Interest in the same data.</p> <p>When NFD receives an Interest, it first looks up the PIT for an entry matching the Interest. If such an entry is found, the Interest is aggregated with the existing entry, by appending an in-record to the entry for the incoming face of the new Interest. The Interest is then not forwarded further.</p> <p>When a matching Data packet is received, it is forwarded on all the incoming faces of the PIT entry. As a result, multiple Interests are satisfied with a single Data packet, thus realizing Data multicast.</p> <p>Multicast and Interest Selectors</p> <p>Interests can generally be aggregated only if they have the same name and selectors. For instance, two Interests having the same name but different values for the <code>MustBeFresh</code> selector cannot be aggregated, since they are potentially requesting different Data packets.</p>"},{"location":"forwarding/#consumer-privacy","title":"Consumer Privacy","text":"<p>Since the PIT stores the incoming face of each Interest, the outgoing Interest does not need to contain any information about the incoming face. This enables consumer privacy in NDN, by ensuring that Interest packets cannot be used to identify the original sender.</p>"},{"location":"forwarding/#loop-detection","title":"Loop Detection","text":"<p>The PIT also lets NFD detect and prevent looping Interests. Each Interest in NDN carries a randomly generated nonce, which is stored in the PIT entry along with the Interest name. When NFD receives an Interest, it first looks up the PIT for an entry matching the Interest. If such an entry is found including a matching nonce, then the incoming Interest is dropped.</p> <p>Longer Loops</p> <p>While the PIT prevents some types of looping Interests, it fails to detect longer loops, since an Interest may be satisfied by a Data packet before it loops back to the same forwarder. To detect such looping Interests, NFD uses a separate table called the Dead Nonce List, which stores nonces of recently satisfied Interests.</p>"},{"location":"forwarding/#content-store","title":"Content Store","text":"<p>The Content Store is a cache of Data packets, which is used by NFD to satisfy Interests. When NFD receives an Interest, it first looks up the Content Store for a matching Data packet before looking up the FIB and Strategy Tables. If a matching Data packet is found, it is directly used to satisfy the Interest, and the Interest is not forwarded further.</p> <p>The Content Store is a key component of NDN, since it enables Data caching at the network layer. As a result, NDN supports both synchronous and asynchronous multicast of Data packets.</p> <p>Data Freshness</p> <p>NDN Data packets carry a <code>FreshnessPeriod</code>, which specifies the time in milliseconds for which the data is fresh. A Data packet cached earlier than its freshness period is considered \"non-fresh\", and cannot be used to satisfy Interests with the <code>MustBeFresh</code> selector.</p> <ol> <li> <p>Yi, C. et al. 2013. A case for stateful forwarding plane. Computer Communications. 36, 7 (2013), 779\u2013791. DOI:https://doi.org/https://doi.org/10.1016/j.comcom.2013.01.005.\u00a0\u21a9</p> </li> <li> <p>Song, S. and Zhang, L. 2022. Effective NDN congestion control based on queue size feedback. Proceedings of the 9th ACM conference on information-centric networking (New York, NY, USA, 2022), 11\u201321.\u00a0\u21a9</p> </li> <li> <p>Gasti, P. et al. 2013. DoS and DDoS in named data networking. 2013 22nd international conference on computer communication and networks (ICCCN) (2013), 1\u20137.\u00a0\u21a9</p> </li> <li> <p>Lehman, V. et al. 2016. An experimental investigation of hyperbolic routing with a smart forwarding plane in NDN. 2016 IEEE/ACM 24th international symposium on quality of service (IWQoS) (2016), 1\u201310.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This page will guide you through the process of installing the basic tools needed to start using and developing NDN applications.</p>"},{"location":"getting-started/#packet-forwarder","title":"Packet Forwarder","text":"<p>To begin, you will need to first install the NDN Forwarding Daemon (NFD) on your computer. There are several implementations of NFD, the most popular of which are:</p> <ul> <li>NFD1, the reference implementation (C++)</li> <li>YaNFD2, a multithreaded implementation (Golang)</li> <li>NDN-DPDK3, a high-performance implementation (C)</li> <li>NDN-Lite4, an IoT implementation (C)</li> </ul> <p>What is the role of NFD?</p> <p>NFD is the NDN equivalent of an IP \"router\", and runs on each node in the network. It is responsible for forwarding NDN packets between nodes, including functions of Data multicast and caching.</p>"},{"location":"getting-started/#client-library","title":"Client Library","text":"<p>Next, you will need to install a client library of your choice to interact with the NDN network. Depending on the library, you will need the corresponding compilers / interpreters / build tools.</p> <ul> <li>ndn-cxx (C++) [Docs, API]</li> <li>python-ndn (Python) [Docs]</li> <li>NDNts (TypeScript) [Docs]</li> <li>go-ndn (Golang)</li> <li>NDN-Lite (C, IoT) [Docs, API]</li> <li>esp8266ndn (Arduino) [API]</li> </ul> <p>What does the client library do?</p> <p>The client library provides the NDN equivalent of a TCP/IP \"socket\", and runs inside each application. It is responsible for encoding and decoding NDN packets, and sending / receiving them to / from NFD.</p> <p>Once you have installed NFD and a client library, you need to start NFD on your local development machine. You are now ready to start developing NDN applications!</p> <p>Contributing to the NDN codebase</p> <p>The NDN codebase is free and open-source software, and most of it is available on GitHub. If you are interested in contributing, make sure you read this guide and the code of conduct first.</p>"},{"location":"getting-started/#debugging-tools","title":"Debugging Tools","text":"<p>The ndn-tools package is highly recommended and contains several tools for developing and debugging NDN applications.</p> <ul> <li>peek: transmit a single Interest/Data packet between a consumer and a producer.</li> <li>chunks: segmented file transfer between a consumer and a producer.</li> <li>ping: test reachability between two NDN nodes</li> <li>dump: capture and analyze live traffic on an NDN network</li> <li>dissect: inspect the TLV structure of an NDN packet</li> <li>dissect-wireshark: Wireshark extension to inspect the TLV structure of NDN packets</li> </ul> <p>Ping test for NFD</p> <p>You can run a simple test for your local NFD by using thee ndn-tools package to start a ping server and client on the same machine. These will then communicate by connecting to NFD over a unix socket.</p> <pre><code>ndnpingserver /my/nfd/test &amp;\nndnping /my/nfd/test\n</code></pre>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<p>If you have any questions about NDN or the code base, we encourage you to reach out to the community for help. Some options include,</p> <ul> <li>Ask a question at the most appropriate mailing list.</li> <li>File an issue at the relevant GitHub repository or Redmine.</li> <li>(If applicable) reach out to the authors of the paper that introduced the software.</li> </ul> <ol> <li> <p>Afanasyev, A. et al. 2014. NFD developer\u2019s guide. Dept. Comput. Sci., Univ. California, Los Angeles, Los Angeles, CA, USA, Tech. Rep. NDN-0021. 29, (2014), 31.\u00a0\u21a9</p> </li> <li> <p>Newberry, E. et al. 2021. YaNFD: Yet another named data networking forwarding daemon. Proceedings of the 8th ACM conference on information-centric networking (New York, NY, USA, 2021), 30\u201341.\u00a0\u21a9</p> </li> <li> <p>Shi, J. et al. 2020. NDN-DPDK: NDN forwarding at 100 gbps on commodity hardware. Proceedings of the 7th ACM conference on information-centric networking (New York, NY, USA, 2020), 30\u201340.\u00a0\u21a9</p> </li> <li> <p>Zhang, Z. et al. 2018. NDNoT: A framework for named data network of things. Proceedings of the 5th ACM conference on information-centric networking (New York, NY, USA, 2018), 200\u2013201.\u00a0\u21a9</p> </li> </ol>"},{"location":"packets/","title":"Packet Types","text":"<p>At a high level, NDN defines two distinct types of packets:</p> <ul> <li>Interest packets are used to request data from the network. The most important component of an Interest packet is the name of the data being requested. An Interest may contain additional parameters such as a lifetime or hop limit, which are referred to as selectors.</li> <li>Data packets carry the actual data being requested, along with the name of the Data and a cryptographic signature. On receiving an Interest packet, nodes in the network may respond with a Data matching the name in the Interest.</li> </ul> <p>How are NDN packets used?</p> <p>Interest and Data packets are used in a request-response fashion. An NDN application sends an Interest packet to request data from the network, and receives a single Data packet in response.</p> <p>The following example illustrates the basic structure of Interest and Data packets.</p> <pre><code>classDiagram\n  Interest &lt;|-- Data\n  class Interest{\n    Name = /edu/ucla/cs/118/notes\n    Lifetime = 5000 ms\n  }\n  class Data{\n    Name = /edu/ucla/cs/118/notes\n    Content = \"Hello, NDN!\"\n    Signature = 3046022100e773b\n  }</code></pre> <p><code>CanBePrefix</code> Interest Selector</p> <p>In this example, the name of the Interest and Data packets is an exact match. If the <code>CanBePrefix</code> selector is specified on the Interest, the name of a matching Data packet may be longer than the name of the Interest packet, as long as it has the name of the Interest as a prefix.</p> <p>Data Signing</p> <p>It is important to note that a Data packet is required to carry a signature to be considered valid.</p>"},{"location":"packets/#tlv-encoding","title":"TLV Encoding","text":"<p>On the wire, NDN packets are represented using the Type-Length-Value (NDN TLV1) encoding scheme. TLV is a highly efficient binary encoding scheme that supports variable length fields and nested structures.</p> <p>Each field in the packet is encoded as a TLV element, which consists of a type, length, and value. The type and length fields are encoded as variable length integers, and the value field is encoded as a sequence of bytes (which in turn may be another TLV block). Interest and Data packets themselves are also encoded as TLV elements.</p> <p>The following example illustrates the TLV encoding of the Interest and Data packets shown above. The type of the block is specified first (in red, hover for numeric), followed by the length (in blue) and the value.</p> <p>Encoding of Names</p> <p>NDN names are hierarchical and are encoded as a list of components. Each component is treated as an opaque binary value by the network, and may contain any sequence of bytes with no restrictions. For readability, names may be represented using the NDN URI Scheme using slashes as delimiters between components.</p> <p>Packet Format Specification</p> <p>The formal specification for Interest and Data packets and TLV encoding can be accessed here.</p>"},{"location":"packets/#library-functions","title":"Library Functions","text":"<p>This section describes how to encode Interest and Data packets using some of the NDN client libraries. The next page will describe how to use the libraries to send and receive the packets.</p> ndn-cxxpython-ndnNDNts <pre><code>#include &lt;ndn-cxx/face.hpp&gt;\n\nint main(int argc, char** argv)\n{\n// Create an NDN Name from a URI string\nndn::Name name(\"/edu/ucla/cs/118/notes\");\n\n// Create an Interest packet with this name\nndn::Interest interest(name);\n\n// Set the Interest packet's InterestLifetime to 5 seconds\ninterest.setInterestLifetime(ndn::time::seconds(5));\n\n// Create a Data packet with the same name\nndn::Data data(name);\n\n// Set the Data packet's content to \"Hello, NDN!\"\ndata.setContent(ndn::make_span(reinterpret_cast&lt;const uint8_t*&gt;(\"Hello, NDN!\"), 11));\n}\n</code></pre> <pre><code>from ndn.encoding import Name\nfrom ndn.types import Interest, Data\n\n# Create an NDN name from a URI string\nname = Name.from_str('/edu/ucla/cs/118/notes')\n\n# Create an Interest packet with this name\ninterest = Interest(name)\n\n# Set the Interest packet's InterestLifetime to 5 seconds\ninterest.interest_lifetime = 5000\n\n# Create a Data packet with the same name\ndata = Data(name)\n\n# Set the Data packet's content to \"Hello, NDN!\"\ndata.content = b'Hello, NDN!'\n</code></pre> <pre><code>import { Name, Interest, Data } from '@ndn/packet';\nimport { toUtf8 } from '@ndn/util';\n\n// Create an NDN name from a URI string\nconst name = new Name('/edu/ucla/cs/118/notes');\n\n// Create an Interest packet with this name\nconst interest = new Interest(name);\n\n// Set the Interest packet's InterestLifetime to 5 seconds\ninterest.lifetime = 5000;\n\n// Create a Data packet with the same name\nconst data = new Data(name);\n\n// Set the Data packet's content to \"Hello, NDN!\"\ndata.content = toUtf8('Hello, NDN!');\n</code></pre> <ol> <li> <p>Ma, X. et al. 2022. A type-theoretic model on NDN-TLV encoding. Proceedings of the 9th ACM conference on information-centric networking (New York, NY, USA, 2022), 91\u2013102.\u00a0\u21a9</p> </li> </ol>"},{"location":"routing/","title":"Routing","text":"<p>This page is under construction.</p>"},{"location":"security/","title":"Security","text":"<p>This page is under construction.</p>"},{"location":"sync/","title":"Sync Transport","text":"<p>This page is under construction.</p>"},{"location":"testbed/","title":"Research Testbed","text":"<p>This page is under construction.</p> <p>The NDN research testbed is a shared resource created for research purposes, that include software routers at several participating institutions, application host nodes, and other devices. The testbed is used for research and development of NDN software, and for experiments that require a shared NDN infrastructure. It is not intended for production use.</p> <p>https://named-data.net/ndn-testbed/</p>"}]}